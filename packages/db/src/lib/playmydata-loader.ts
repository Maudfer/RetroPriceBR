import { existsSync, readFileSync } from "node:fs";
import { dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { parse } from "csv-parse/sync";

export const PLAYMYDATA_SOURCE = "PLAYMYDATA";
export const PLAYMYDATA_LISTING_NOTE = "PlayMyData autogenerated listing";
const MODULE_DIR = dirname(fileURLToPath(import.meta.url));

const NON_CONSOLE_TOKENS = [
    "pc",
    "windows",
    "mac",
    "linux",
    "ios",
    "android",
    "steam",
    "browser",
    "mobile",
    "smartphone",
    "arcade"
];

export interface NormalizedPlatform {
    externalId: number;
    name: string;
    slug: string;
    vendor?: string;
    isConsole: boolean;
}

export interface NormalizedConsole {
    externalId: number;
    title: string;
    slug: string;
    vendor?: string;
    platformExternalId: number;
}

export interface NormalizedGame {
    externalId: number;
    title: string;
    slug: string;
    platformExternalId: number;
    releaseYear: number | null;
}

export interface PlayMyDataDataset {
    platforms: NormalizedPlatform[];
    consoles: NormalizedConsole[];
    games: NormalizedGame[];
}

export interface LoadPlayMyDataOptions {
    datasetDir?: string;
}

interface RawPlatformRow {
    id: string;
    name: string;
}

interface RawGameRow {
    id: string;
    name: string;
    platforms: string;
    summary?: string;
    storyline?: string;
    genres?: string;
}

const sanitizeValue = (value: string | undefined | null): string | undefined => {
    if (!value) {
        return undefined;
    }

    const trimmed = value.trim();
    if (!trimmed || trimmed.toLowerCase() === "missing" || trimmed.toLowerCase() === "nan") {
        return undefined;
    }

    return trimmed;
};

const parseNumberArray = (raw: string | undefined): number[] => {
    if (!raw) {
        return [];
    }

    const sanitized = sanitizeValue(raw);
    if (!sanitized) {
        return [];
    }

    const matches = sanitized.match(/-?\d+/g);
    if (!matches) {
        return [];
    }

    return matches.map((value) => Number.parseInt(value, 10)).filter((value) => Number.isFinite(value));
};

const inferVendor = (name: string): string | undefined => {
    const lower = name.toLowerCase();

    if (lower.includes("nintendo")) {
        return "Nintendo";
    }

    if (lower.includes("playstation") || lower.includes("sony")) {
        return "Sony";
    }

    if (lower.includes("xbox") || lower.includes("microsoft")) {
        return "Microsoft";
    }

    if (lower.includes("sega")) {
        return "Sega";
    }

    if (lower.includes("atari")) {
        return "Atari";
    }

    if (lower.includes("commodore")) {
        return "Commodore";
    }

    if (lower.includes("amiga")) {
        return "Commodore";
    }

    if (lower.includes("neo geo")) {
        return "SNK";
    }

    if (lower.includes("apple")) {
        return "Apple";
    }

    const firstToken = name.split(/[\s:(-]+/).filter(Boolean)[0];
    if (!firstToken) {
        return undefined;
    }

    return firstToken[0].toUpperCase() + firstToken.slice(1);
};

const isConsolePlatform = (name: string): boolean => {
    const lower = name.toLowerCase();
    return !NON_CONSOLE_TOKENS.some((token) => lower.includes(token));
};

const yearRegex = /(19|20)\d{2}/g;

export const extractReleaseYear = (...candidates: Array<string | undefined>): number | null => {
    const years: number[] = [];

    for (const candidate of candidates) {
        if (!candidate) {
            continue;
        }

        const matches = candidate.match(yearRegex);
        if (!matches) {
            continue;
        }

        for (const value of matches) {
            const parsed = Number.parseInt(value, 10);
            if (parsed >= 1970 && parsed <= 2035) {
                years.push(parsed);
            }
        }
    }

    if (years.length === 0) {
        return null;
    }

    return Math.min(...years);
};

export const slugify = (value: string): string => {
    const normalized = value
        .normalize("NFKD")
        .replace(/[\u0300-\u036f]/g, "")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");

    return normalized || "item";
};

const readPlatformCsv = (datasetDir: string): Map<number, NormalizedPlatform> => {
    const filePath = resolve(datasetDir, "platforms.csv");
    const rawFile = readFileSync(filePath, "utf8");
    const rows = parse(rawFile, {
        columns: ["id", "name"],
        skip_empty_lines: true,
        trim: true
    }) as RawPlatformRow[];

    const platforms = new Map<number, NormalizedPlatform>();

    for (const row of rows) {
        const id = Number.parseInt(row.id, 10);
        if (!Number.isFinite(id)) {
            continue;
        }

        const name = row.name?.trim();
        if (!name) {
            continue;
        }

        const slug = `${slugify(name)}-${id}`;
        platforms.set(id, {
            externalId: id,
            name,
            slug,
            vendor: inferVendor(name),
            isConsole: isConsolePlatform(name)
        });
    }

    return platforms;
};

const GAME_FILES = [
    "all_games_Nintendo.csv",
    "all_games_PlayStation.csv",
    "all_games_Xbox.csv",
    "all_games_PC.csv"
];

export const loadPlayMyDataDataset = (options: LoadPlayMyDataOptions = {}): PlayMyDataDataset => {
    const datasetDir = resolveDatasetDirectory(options.datasetDir);

    const platformMap = readPlatformCsv(datasetDir);
    const games: NormalizedGame[] = [];
    const usedPlatformIds = new Set<number>();
    const seenPairs = new Set<string>();
    const usedSlugs = new Set<string>();

    for (const fileName of GAME_FILES) {
        const filePath = resolve(datasetDir, fileName);
        const fileContent = readFileSync(filePath, "utf8");
        const rows = parse(fileContent, {
            columns: true,
            skip_empty_lines: true,
            trim: true
        }) as RawGameRow[];

        for (const row of rows) {
            const id = Number.parseInt(row.id, 10);
            if (!Number.isFinite(id)) {
                continue;
            }

            const title = sanitizeValue(row.name);
            if (!title) {
                continue;
            }

            const platformIds = parseNumberArray(row.platforms);
            if (platformIds.length === 0) {
                continue;
            }

            const summary = sanitizeValue(row.summary);
            const storyline = sanitizeValue(row.storyline);
            const releaseYear = extractReleaseYear(summary, storyline);

            for (const platformExternalId of platformIds) {
                if (!platformMap.has(platformExternalId)) {
                    continue;
                }

                const key = `${id}:${platformExternalId}`;
                if (seenPairs.has(key)) {
                    continue;
                }

                seenPairs.add(key);
                usedPlatformIds.add(platformExternalId);

                const platform = platformMap.get(platformExternalId)!;
                const gameSlug = `${slugify(title)}-${platform.slug}`;

                if (usedSlugs.has(gameSlug)) {
                    continue;
                }
                usedSlugs.add(gameSlug);

                games.push({
                    externalId: id,
                    title,
                    slug: gameSlug,
                    platformExternalId,
                    releaseYear
                });
            }
        }
    }

    const platforms = Array.from(platformMap.values()).filter((platform) =>
        usedPlatformIds.has(platform.externalId)
    );

    const consoles: NormalizedConsole[] = platforms
        .filter((platform) => platform.isConsole)
        .map((platform) => ({
            externalId: platform.externalId,
            title: platform.name,
            slug: platform.slug,
            vendor: platform.vendor,
            platformExternalId: platform.externalId
        }));

    return {
        platforms,
        consoles,
        games
    };
};

export const chunkArray = <T>(values: T[], size = 500): T[][] => {
    if (size <= 0) {
        return [values];
    }

    const result: T[][] = [];
    for (let index = 0; index < values.length; index += size) {
        result.push(values.slice(index, index + size));
    }

    return result;
};

const resolveDatasetDirectory = (customDir: string | undefined): string => {
    if (customDir) {
        const absolute = resolve(customDir);
        if (!existsSync(absolute)) {
            throw new Error(`PlayMyData dataset directory not found at ${absolute}`);
        }

        return absolute;
    }

    const candidates = [
        resolve(process.cwd(), "../../datasets/PlayMyData"),
        resolve(process.cwd(), "datasets/PlayMyData"),
        resolve(MODULE_DIR, "../../../../datasets/PlayMyData"),
        resolve(MODULE_DIR, "../../../datasets/PlayMyData")
    ];

    for (const candidate of candidates) {
        if (existsSync(candidate)) {
            return candidate;
        }
    }

    throw new Error(
        "PlayMyData dataset directory not found. Set PLAYMYDATA_DIR or ensure datasets/PlayMyData is available."
    );
};